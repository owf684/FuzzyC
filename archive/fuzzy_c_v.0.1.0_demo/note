// demo 1
fuzzy_c has finally begun to take some semblance of an engine.
As you can see there is some physics, some poor downward collision detection, and some input controls.
Felt so rewarding to get this to work I had to record. Thanks internet and chat gpt for helping me learn
about unique ptrs

// demo 2
I have finally figured out how to do collisions well using actual physics and boundary overlap 
Calculations. The collision are way more robust than they've ever been

// demo 3
After much experimentation I finally figured out the best course of action for UI integration was using IMGUI. In this demo I show case the ability to add objects to the scene by clicking around. The ui seen was all built using IMGUI. Thank you Chat GPT

// demo 4
At this point I have figured out how to add objects to the engine, scroll the game scene, simple camera functions, grid for snapping objects to it. This video showcases the scrolling grid during 
Editing and playing

// demo 5
Realizing that the collision engine was trash I needed to implement some actually good collision detection. I studied quad trees and figured out how to implement my own. Once that was built up through various tests. I tested it and the performance was horrible. I used the Xcode profiler and found that the search function was being called too much. Increasing the layers of the quad tree helped some, but the biggest revelation came to me. I only need to search the environment if the object is actively moving, doing something, or waiting for player interaction. The rest of the environments are just platforms for the player to step on. So I added a bool called detect_collisions
In the collider component. This allowed me then to only search the quad tree if this bool was set true. This reduced the search cpu consumption from 50% down to 2%. That is a huge improvement. The next huge improvement was when the profiler revealed that the graphics_engine was just eating CPU as well. The reason was that it was creating/destroying textures every iteration of the game loop, so I had the brilliant idea to instead load the texture in upon object creation, and to delete the text upon object deletion. That easy! That improved performance as well. This clip may not seem like much, but it took so much effort to be able to scroll this smoothly.